// TestLibrary.Enum



/* ---------------------------------------------------------------------------- *
 *		The code is generated by 'T4Wrap' C# proxy generator T4 template		*
 * ---------------------------------------------------------------------------- */

namespace TestLibrary.Proxies
{
	using System;

	[System.Serializable, System.Flags] 
	public enum EnumWrapper : int 
	{
		[System.Obsolete] 
		Enum1 = 0,
		Enum2 = 1,
		Enum3 = 2,
		EnumX = 99,
	}

	public static class EnumWrapperExtensions 
	{
		public static EnumWrapper ToWrapper(this TestLibrary.Enum source)
		{
			switch(source)
			{
				case TestLibrary.Enum.Enum1:
					return EnumWrapper.Enum1;

				case TestLibrary.Enum.Enum2:
					return EnumWrapper.Enum2;

				case TestLibrary.Enum.Enum3:
					return EnumWrapper.Enum3;

				case TestLibrary.Enum.EnumX:
					return EnumWrapper.EnumX;

				default:
					throw new ArgumentOutOfRangeException(nameof(source), source, $"No implementation for enum TestLibrary.Enum value {source}");
			}
		}

		public static TestLibrary.Enum FromWrapper(this EnumWrapper source)
		{
			switch(source)
			{
				case EnumWrapper.Enum1:
					return TestLibrary.Enum.Enum1;

				case EnumWrapper.Enum2:
					return TestLibrary.Enum.Enum2;

				case EnumWrapper.Enum3:
					return TestLibrary.Enum.Enum3;

				case EnumWrapper.EnumX:
					return TestLibrary.Enum.EnumX;

				default:
					throw new ArgumentOutOfRangeException(nameof(source), source, $"No implementation for enum EnumWrapper value {source}");
			}
		}
	}
}

// TestLibrary.AbstractClass
/* ---------------------------------------------------------------------------- *
 *		The code is generated by 'T4Wrap' C# proxy generator T4 template		*
 * ---------------------------------------------------------------------------- */

namespace TestLibrary.Proxies
{
	public class AbstractClassWrapper : System.Object, IAbstractClassWrapper
	{
		//private TestLibrary.AbstractClass Inner;

		internal TestLibrary.AbstractClass Inner { get; }





	}

	public interface IAbstractClassWrapper
	{

	}

	public interface IAbstractClassWrapperFactory
	{
		IAbstractClassWrapper Create(params object[] args);
	}


	public class AbstractClassWrapperFactory : IAbstractClassWrapperFactory
	{
		public virtual IAbstractClassWrapper Create(params object[] args)
		{
			return (IAbstractClassWrapper)System.Activator.CreateInstance(typeof(AbstractClassWrapper), args);
		}

	}
}
// TestLibrary.Class
/* ---------------------------------------------------------------------------- *
 *		The code is generated by 'T4Wrap' C# proxy generator T4 template		*
 * ---------------------------------------------------------------------------- */

namespace TestLibrary.Proxies
{
	public class ClassWrapper : AbstractClassWrapper, IClassWrapper, Interface1Wrapper
	{
		//private TestLibrary.Class Inner;

		internal TestLibrary.Class Inner { get; }

		#region Constructors
		public ClassWrapper()
		{
			Inner = new TestLibrary.Class();
		}
		#endregion

		#region Properties
		public virtual string ReadWrite
		{
			get { return Inner.ReadWrite; }			set { Inner.ReadWrite = value; }
	
		}
		public virtual string Read
		{
			get { return Inner.Read; }	
		}
		public virtual string this[int i, int j]
		{				
			get { return Inner[i, j]; }			set{ Inner[i, j] = value; }		}
		public virtual string this[int i]
		{				
			get { return Inner[i]; }			set{ Inner[i] = value; }		}
		#endregion

		#region Static Methods
		public static void StaticMethod1()
		{
			TestLibrary.Class.StaticMethod1();
		}
		#endregion

		#region Methods
		public virtual void Method1()
		{
			Inner.Method1();
		}
		public virtual void Method2(string str)
		{
			Inner.Method2(str);
		}
		public virtual void Method3(string str)
		{
			Inner.Method3(str);
		}
		public virtual void Method4(ref string str)
		{
			Inner.Method4(ref str);
		}
		public virtual void Method5([TestLibrary.Attribute] out string str)
		{
			Inner.Method5(out str);
		}
		public virtual void Method6(string str, bool isBool = true)
		{
			Inner.Method6(str, isBool);
		}
		public virtual void Method7(string str, bool isBool = true)
		{
			Inner.Method7(str, isBool);
		}
		#endregion

		#region Interface1Wrapper Members
			
		string Interface1Wrapper.this[int i]
		{
			get { return ((TestLibrary.Interface1)Inner)[i]; }
			set { ((TestLibrary.Interface1)Inner)[i] = value; }		}
			
		string Interface1Wrapper.this[int i, int j]
		{
			get { return ((TestLibrary.Interface1)Inner)[i, j]; }
			set { ((TestLibrary.Interface1)Inner)[i, j] = value; }		}
		string Interface1Wrapper.ReadWrite
		{
			get { return ((TestLibrary.Interface1)Inner).ReadWrite; }
			set { ((TestLibrary.Interface1)Inner).ReadWrite = value; }
		}
		string Interface1Wrapper.Read
		{
			get { return ((TestLibrary.Interface1)Inner).Read; }
		}
		void Interface1Wrapper.Method1()
		{
			((TestLibrary.Interface1)Inner).Method1();
		}
		void Interface1Wrapper.Method2(string str)
		{
			((TestLibrary.Interface1)Inner).Method2(str);
		}
		void Interface1Wrapper.Method3(string str)
		{
			((TestLibrary.Interface1)Inner).Method3(str);
		}
		void Interface1Wrapper.Method4(ref string str)
		{
			((TestLibrary.Interface1)Inner).Method4(ref str);
		}
		void Interface1Wrapper.Method5(out string str)
		{
			((TestLibrary.Interface1)Inner).Method5(out str);
		}
		void Interface1Wrapper.Method6(string str, bool isBool)
		{
			((TestLibrary.Interface1)Inner).Method6(str, isBool);
		}
		void Interface1Wrapper.Method7(string str, bool isBool)
		{
			((TestLibrary.Interface1)Inner).Method7(str, isBool);
		}
		#endregion
	}

	public interface IClassWrapper
	{
		#region Properties
 		string ReadWrite { get; set; }
 		string Read { get; }
			
		string this[int i, int j]
{ get; set; }
			
		string this[int i]
{ get; set; }
		#endregion

		#region Methods
		void Method1();			
		void Method2(string str);			
		void Method3(string str);			
		void Method4(ref string str);			
		void Method5(out string str);			
		void Method6(string str, bool isBool);			
		void Method7(string str, bool isBool);			
		#endregion
	}

	public interface IClassWrapperFactory
	{
		IClassWrapper Create(params object[] args);
		IClassWrapper Create();
	}

	public interface IStaticClassWrapper
	{
		#region Methods
		void StaticMethod1();
		#endregion
	}

	public class ClassWrapperFactory : IClassWrapperFactory
	{
		public virtual IClassWrapper Create(params object[] args)
		{
			return (IClassWrapper)System.Activator.CreateInstance(typeof(ClassWrapper), args);
		}

		public virtual IClassWrapper Create()
		{
			return new ClassWrapper(); 
		}
	}
}
// TestLibrary.SealedClass
/* ---------------------------------------------------------------------------- *
 *		The code is generated by 'T4Wrap' C# proxy generator T4 template		*
 * ---------------------------------------------------------------------------- */

namespace TestLibrary.Proxies
{
	public class SealedClassWrapper : ClassWrapper, ISealedClassWrapper, Interface1Wrapper
	{
		//private TestLibrary.SealedClass Inner;

		internal TestLibrary.SealedClass Inner { get; }

		#region Constructors
		public SealedClassWrapper()
		{
			Inner = new TestLibrary.SealedClass();
		}
		#endregion
		
		#region Interface1Wrapper Members
		string Interface1Wrapper.this[int i]
		{
			get { return ((TestLibrary.Interface1)Inner)[i]; }
			set { ((TestLibrary.Interface1)Inner)[i] = value; }		}
			
		string Interface1Wrapper.this[int i, int j]
		{
			get { return ((TestLibrary.Interface1)Inner)[i, j]; }
			set { ((TestLibrary.Interface1)Inner)[i, j] = value; }		}
		string Interface1Wrapper.ReadWrite
		{
			get { return ((TestLibrary.Interface1)Inner).ReadWrite; }
			set { ((TestLibrary.Interface1)Inner).ReadWrite = value; }
		}
		string Interface1Wrapper.Read
		{
			get { return ((TestLibrary.Interface1)Inner).Read; }
		}
		void Interface1Wrapper.Method1()
		{
			((TestLibrary.Interface1)Inner).Method1();
		}
		void Interface1Wrapper.Method2(string str)
		{
			((TestLibrary.Interface1)Inner).Method2(str);
		}
		void Interface1Wrapper.Method3(string str)
		{
			((TestLibrary.Interface1)Inner).Method3(str);
		}
		void Interface1Wrapper.Method4(ref string str)
		{
			((TestLibrary.Interface1)Inner).Method4(ref str);
		}
		void Interface1Wrapper.Method5(out string str)
		{
			((TestLibrary.Interface1)Inner).Method5(out str);
		}
		void Interface1Wrapper.Method6(string str, bool isBool)
		{
			((TestLibrary.Interface1)Inner).Method6(str, isBool);
		}
		void Interface1Wrapper.Method7(string str, bool isBool)
		{
			((TestLibrary.Interface1)Inner).Method7(str, isBool);
		}
		#endregion
	}

	public interface ISealedClassWrapper
	{

	}

	public interface ISealedClassWrapperFactory
	{
		ISealedClassWrapper Create(params object[] args);
		ISealedClassWrapper Create();
	}


	public class SealedClassWrapperFactory : ISealedClassWrapperFactory
	{
		public virtual ISealedClassWrapper Create(params object[] args)
		{
			return (ISealedClassWrapper)System.Activator.CreateInstance(typeof(SealedClassWrapper), args);
		}

		public virtual ISealedClassWrapper Create()
		{
			return new SealedClassWrapper(); 
		}
	}
}
// TestLibrary.Helper
/* ---------------------------------------------------------------------------- *
 *		The code is generated by 'T4Wrap' C# proxy generator T4 template		*
 * ---------------------------------------------------------------------------- */

namespace TestLibrary.Proxies
{
	public class HelperWrapper : System.Object, IHelperWrapper
	{
		//private TestLibrary.Helper Inner;

		internal TestLibrary.Helper Inner { get; }



		#region Static Methods
		public static void Helper1()
		{
			TestLibrary.Helper.Helper1();
		}
		#endregion


	}

	public interface IHelperWrapper
	{

	}

	public interface IHelperWrapperFactory
	{
		IHelperWrapper Create(params object[] args);
	}

	public interface IStaticHelperWrapper
	{
		#region Methods
		void Helper1();
		#endregion
	}

	public class HelperWrapperFactory : IHelperWrapperFactory
	{
		public virtual IHelperWrapper Create(params object[] args)
		{
			return (IHelperWrapper)System.Activator.CreateInstance(typeof(HelperWrapper), args);
		}

	}
}
// TestLibrary.Interface1
/* ---------------------------------------------------------------------------- *
 *		The code is generated by 'T4Wrap' C# proxy generator T4 template		*
 * ---------------------------------------------------------------------------- */

namespace TestLibrary.Proxies
{
	public interface Interface1Wrapper 
	{
		#region Properties
		string this[int i] { get; set; }
		string this[int i, int j] { get; set; }
		string ReadWrite { get; set; }
		string Read { get; }
		#endregion
		#region Methods
		void Method1();
		void Method2(string str);
		void Method3([TestLibrary.Attribute] string str);
		void Method4([TestLibrary.Attribute] ref string str);
		void Method5([TestLibrary.Attribute] out string str);
		void Method6([TestLibrary.Attribute] string str, bool isBool);
		void Method7([TestLibrary.Attribute] string str, bool isBool = true);
		#endregion
	}

	public interface IStaticInterface1Wrapper
	{

	}
}


// TestLibrary.AttributeAttribute
/* ---------------------------------------------------------------------------- *
 *		The code is generated by 'T4Wrap' C# proxy generator T4 template		*
 * ---------------------------------------------------------------------------- */

namespace TestLibrary.Proxies
{
	public class AttributeAttributeWrapper : System.Attribute, IAttributeAttributeWrapper
	{
		//private TestLibrary.AttributeAttribute Inner;

		internal TestLibrary.AttributeAttribute Inner { get; }

		#region Constructors
		public AttributeAttributeWrapper()
		{
			Inner = new TestLibrary.AttributeAttribute();
		}
		#endregion




	}

	public interface IAttributeAttributeWrapper
	{

	}

	public interface IAttributeAttributeWrapperFactory
	{
		IAttributeAttributeWrapper Create(params object[] args);
		IAttributeAttributeWrapper Create();
	}


	public class AttributeAttributeWrapperFactory : IAttributeAttributeWrapperFactory
	{
		public virtual IAttributeAttributeWrapper Create(params object[] args)
		{
			return (IAttributeAttributeWrapper)System.Activator.CreateInstance(typeof(AttributeAttributeWrapper), args);
		}

		public virtual IAttributeAttributeWrapper Create()
		{
			return new AttributeAttributeWrapper(); 
		}
	}
}
		
