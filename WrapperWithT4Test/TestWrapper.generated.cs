// TestLibrary.AbstractClass
/* ---------------------------------------------------------------------------- *
 *		The code is generated by 'T4Wrap' C# proxy generator T4 template		*
 * ---------------------------------------------------------------------------- */

namespace TestLibrary.Proxies
{
	public interface IAbstractClassWrapper
	{


	}

	public class AbstractClassWrapper : System.Object, IAbstractClassWrapper
	{
		//private TestLibrary.AbstractClass Inner;

		internal TestLibrary.AbstractClass Inner { get; }






	}


	public interface IAbstractClassWrapperFactory
	{
		IAbstractClassWrapper Create(params object[] args);
	}


	public class AbstractClassWrapperFactory : IAbstractClassWrapperFactory
	{
		public virtual IAbstractClassWrapper Create(params object[] args)
		{
			return (IAbstractClassWrapper)System.Activator.CreateInstance(typeof(AbstractClassWrapper), args);
		}

	}

}
// TestLibrary.Class
/* ---------------------------------------------------------------------------- *
 *		The code is generated by 'T4Wrap' C# proxy generator T4 template		*
 * ---------------------------------------------------------------------------- */

namespace TestLibrary.Proxies
{
	public interface IClassWrapper
	{
		#region Events
		event System.EventHandler Event1;
		#endregion

		#region Properties
		string ReadWrite { get; set; }
		string Read { get; }
		string this[int i, int j] { get; set; }			
		string this[int i] { get; set; }			
		#endregion

		#region Methods
	 	void Method1();
	 	void Method2(string str);
	 	void Method3(string str);
	 	void Method4(ref string str);
	 	void Method5([TestLibrary.Attribute] out string str);
	 	void Method6(string str, bool isBool = true);
	 	void Method7(string str, bool isBool = true);
	 	void PublicDelegateMethod1(publicDelegate1Wrapper del);
	 	publicDelegate1Wrapper PublicDelegateMethod2();
	 	publicDelegate1Wrapper PublicDelegateMethod3(publicDelegate2Wrapper del);
	 	publicDelegate1Wrapper PublicDelegateMethod4(publicDelegate2Wrapper del1, publicDelegate3Wrapper del2);
	 	void StaticMethod1();
		#endregion
	}

	public class ClassWrapper : AbstractClassWrapper, IClassWrapper, Interface1Wrapper
	{
		//private TestLibrary.Class Inner;

		internal TestLibrary.Class Inner { get; }

		#region Constructors
		public ClassWrapper()
		{
			this.Inner = new TestLibrary.Class();
			Inner.Event1 += (sender, e) => { if (this.Event1 != null) this.Event1(sender, e); };
		}
		#endregion

		#region Events
		public virtual event System.EventHandler Event1;
		#endregion

		#region Properties
		public virtual string ReadWrite
		{
			get { return Inner.ReadWrite; }
			set { Inner.ReadWrite = value; }
		}
		public virtual string Read
		{
			get { return Inner.Read; }
		}
		public virtual string this[int i, int j]
		{
			get { return Inner[i, j]; }
			set { Inner[i, j] = value; }
		}
		public virtual string this[int i]
		{
			get { return Inner[i]; }
			set { Inner[i] = value; }
		}
		#endregion

		#region Methods
		public virtual void StaticMethod1()
		{
			TestLibrary.Class.StaticMethod1();
		}
		#endregion

		#region Methods
		public virtual void Method1()
		{
			Inner.Method1();
		}
		public virtual void Method2(string str)
		{
			Inner.Method2(str);
		}
		public virtual void Method3(string str)
		{
			Inner.Method3(str);
		}
		public virtual void Method4(ref string str)
		{
			Inner.Method4(ref str);
		}
		public virtual void Method5([TestLibrary.Attribute] out string str)
		{
			Inner.Method5(out str);
		}
		public virtual void Method6(string str, bool isBool = true)
		{
			Inner.Method6(str, isBool);
		}
		public virtual void Method7(string str, bool isBool = true)
		{
			Inner.Method7(str, isBool);
		}
		public virtual void PublicDelegateMethod1(publicDelegate1Wrapper del)
		{
			Inner.PublicDelegateMethod1(new TestLibrary.Class.publicDelegate1(del));
		}
		public virtual publicDelegate1Wrapper PublicDelegateMethod2()
		{
			return new publicDelegate1Wrapper(Inner.PublicDelegateMethod2());
		}
		public virtual publicDelegate1Wrapper PublicDelegateMethod3(publicDelegate2Wrapper del)
		{
			return new publicDelegate1Wrapper(Inner.PublicDelegateMethod3(new TestLibrary.Class.publicDelegate2(del)));
		}
		public virtual publicDelegate1Wrapper PublicDelegateMethod4(publicDelegate2Wrapper del1, publicDelegate3Wrapper del2)
		{
			return new publicDelegate1Wrapper(Inner.PublicDelegateMethod4(new TestLibrary.Class.publicDelegate2(del1), new TestLibrary.Class.publicDelegate3(del2)));
		}
		#endregion

		#region Interface1Wrapper Members

		string Interface1Wrapper.this[int i]
		{
			get { return Inner[i]; }
			set { Inner[i] = value; }
		}
		string Interface1Wrapper.this[int i, int j]
		{
			get { return Inner[i, j]; }
			set { Inner[i, j] = value; }
		}
		string Interface1Wrapper.ReadWrite
		{
			get { return Inner.ReadWrite; }
			set { Inner.ReadWrite = value; }
		}
		string Interface1Wrapper.Read
		{
			get { return Inner.Read; }
		}

		void Interface1Wrapper.Method1()
		{
			Inner.Method1();
		}
		void Interface1Wrapper.Method2(string str)
		{
			Inner.Method2(str);
		}
		void Interface1Wrapper.Method3([TestLibrary.Attribute] string str)
		{
			Inner.Method3(str);
		}
		void Interface1Wrapper.Method4([TestLibrary.Attribute] ref string str)
		{
			Inner.Method4(ref str);
		}
		void Interface1Wrapper.Method5([TestLibrary.Attribute] out string str)
		{
			Inner.Method5(out str);
		}
		void Interface1Wrapper.Method6([TestLibrary.Attribute] string str, bool isBool)
		{
			Inner.Method6(str, isBool);
		}
		void Interface1Wrapper.Method7([TestLibrary.Attribute] string str, bool isBool = true)
		{
			Inner.Method7(str, isBool);
		}
		#endregion
	}


	public interface IClassWrapperFactory
	{
		IClassWrapper Create(params object[] args);
		IClassWrapper Create();
	}

	public interface IStaticClassWrapper
	{
		#region Methods
		void StaticMethod1();
		#endregion
	}

	public class ClassWrapperFactory : IClassWrapperFactory
	{
		public virtual IClassWrapper Create(params object[] args)
		{
			return (IClassWrapper)System.Activator.CreateInstance(typeof(ClassWrapper), args);
		}

		public virtual IClassWrapper Create()
		{
			return new ClassWrapper(); 
		}
	}

}
// TestLibrary.Enum



/* ---------------------------------------------------------------------------- *
 *		The code is generated by 'T4Wrap' C# proxy generator T4 template		*
 * ---------------------------------------------------------------------------- */

namespace TestLibrary.Proxies
{
	using System;

	[System.Serializable, System.Flags] 
	public enum EnumWrapper : int 
	{
		[System.Obsolete] 
		Enum1 = 0,
		Enum2 = 1,
		Enum3 = 2,
		EnumX = 99,
	}

	public static class EnumWrapperExtensions 
	{
		public static EnumWrapper ToWrapper(this TestLibrary.Enum source)
		{
			switch(source)
			{
				case TestLibrary.Enum.Enum1:
					return EnumWrapper.Enum1;

				case TestLibrary.Enum.Enum2:
					return EnumWrapper.Enum2;

				case TestLibrary.Enum.Enum3:
					return EnumWrapper.Enum3;

				case TestLibrary.Enum.EnumX:
					return EnumWrapper.EnumX;

				default:
					throw new ArgumentOutOfRangeException(nameof(source), source, $"No implementation for enum TestLibrary.Enum value {source}");
			}
		}

		public static TestLibrary.Enum FromWrapper(this EnumWrapper source)
		{
			switch(source)
			{
				case EnumWrapper.Enum1:
					return TestLibrary.Enum.Enum1;

				case EnumWrapper.Enum2:
					return TestLibrary.Enum.Enum2;

				case EnumWrapper.Enum3:
					return TestLibrary.Enum.Enum3;

				case EnumWrapper.EnumX:
					return TestLibrary.Enum.EnumX;

				default:
					throw new ArgumentOutOfRangeException(nameof(source), source, $"No implementation for enum EnumWrapper value {source}");
			}
		}
	}
}

// TestLibrary.Helper
/* ---------------------------------------------------------------------------- *
 *		The code is generated by 'T4Wrap' C# proxy generator T4 template		*
 * ---------------------------------------------------------------------------- */

namespace TestLibrary.Proxies
{
	public interface IHelperWrapper
	{


		#region Methods
	 	void Helper1();
	 	string Extention1(ClassWrapper c);
		#endregion
	}

	public class HelperWrapper : System.Object, IHelperWrapper
	{
		//private TestLibrary.Helper Inner;




		#region Methods
		public virtual void Helper1()
		{
			TestLibrary.Helper.Helper1();
		}
		public virtual string Extention1(ClassWrapper c)
		{
			return TestLibrary.Helper.Extention1(c.Inner);
		}
		#endregion


	}


	public interface IHelperWrapperFactory
	{
		IHelperWrapper Create(params object[] args);
	}

	public interface IStaticHelperWrapper
	{
		#region Methods
		void Helper1();
		string Extention1(ClassWrapper c);
		#endregion
	}

	public class HelperWrapperFactory : IHelperWrapperFactory
	{
		public virtual IHelperWrapper Create(params object[] args)
		{
			return (IHelperWrapper)System.Activator.CreateInstance(typeof(HelperWrapper), args);
		}

	}

}
// TestLibrary.Interface1
/* ---------------------------------------------------------------------------- *
 *		The code is generated by 'T4Wrap' C# proxy generator T4 template		*
 * ---------------------------------------------------------------------------- */

namespace TestLibrary.Proxies
{
	public interface Interface1Wrapper 
	{
		#region Properties
		string this[int i] { get; set; }
		string this[int i, int j] { get; set; }
		string ReadWrite { get; set; }
		string Read { get; }
		#endregion
		#region Methods
		void Method1();
		void Method2(string str);
		void Method3([TestLibrary.Attribute] string str);
		void Method4([TestLibrary.Attribute] ref string str);
		void Method5([TestLibrary.Attribute] out string str);
		void Method6([TestLibrary.Attribute] string str, bool isBool);
		void Method7([TestLibrary.Attribute] string str, bool isBool = true);
		#endregion
	}
}


// TestLibrary.AttributeAttribute
/* ---------------------------------------------------------------------------- *
 *		The code is generated by 'T4Wrap' C# proxy generator T4 template		*
 * ---------------------------------------------------------------------------- */

namespace TestLibrary.Proxies
{
	public interface IAttributeAttributeWrapper
	{


	}

	public class AttributeAttributeWrapper : System.Attribute, IAttributeAttributeWrapper
	{
		//private TestLibrary.AttributeAttribute Inner;

		internal TestLibrary.AttributeAttribute Inner { get; }

		#region Constructors
		public AttributeAttributeWrapper()
		{
			this.Inner = new TestLibrary.AttributeAttribute();
		}
		#endregion





	}


	public interface IAttributeAttributeWrapperFactory
	{
		IAttributeAttributeWrapper Create(params object[] args);
		IAttributeAttributeWrapper Create();
	}


	public class AttributeAttributeWrapperFactory : IAttributeAttributeWrapperFactory
	{
		public virtual IAttributeAttributeWrapper Create(params object[] args)
		{
			return (IAttributeAttributeWrapper)System.Activator.CreateInstance(typeof(AttributeAttributeWrapper), args);
		}

		public virtual IAttributeAttributeWrapper Create()
		{
			return new AttributeAttributeWrapper(); 
		}
	}

}
// TestLibrary.SealedClass
/* ---------------------------------------------------------------------------- *
 *		The code is generated by 'T4Wrap' C# proxy generator T4 template		*
 * ---------------------------------------------------------------------------- */

namespace TestLibrary.Proxies
{
	public interface ISealedClassWrapper
	{


	}

	public class SealedClassWrapper : ClassWrapper, ISealedClassWrapper, Interface1Wrapper
	{
		//private TestLibrary.SealedClass Inner;

		internal TestLibrary.SealedClass Inner { get; }

		#region Constructors
		public SealedClassWrapper()
		{
			this.Inner = new TestLibrary.SealedClass();
		}
		#endregion





		#region Interface1Wrapper Members

		string Interface1Wrapper.this[int i]
		{
			get { return Inner[i]; }
			set { Inner[i] = value; }
		}
		string Interface1Wrapper.this[int i, int j]
		{
			get { return Inner[i, j]; }
			set { Inner[i, j] = value; }
		}
		string Interface1Wrapper.ReadWrite
		{
			get { return Inner.ReadWrite; }
			set { Inner.ReadWrite = value; }
		}
		string Interface1Wrapper.Read
		{
			get { return Inner.Read; }
		}

		void Interface1Wrapper.Method1()
		{
			Inner.Method1();
		}
		void Interface1Wrapper.Method2(string str)
		{
			Inner.Method2(str);
		}
		void Interface1Wrapper.Method3([TestLibrary.Attribute] string str)
		{
			Inner.Method3(str);
		}
		void Interface1Wrapper.Method4([TestLibrary.Attribute] ref string str)
		{
			Inner.Method4(ref str);
		}
		void Interface1Wrapper.Method5([TestLibrary.Attribute] out string str)
		{
			Inner.Method5(out str);
		}
		void Interface1Wrapper.Method6([TestLibrary.Attribute] string str, bool isBool)
		{
			Inner.Method6(str, isBool);
		}
		void Interface1Wrapper.Method7([TestLibrary.Attribute] string str, bool isBool = true)
		{
			Inner.Method7(str, isBool);
		}
		#endregion
	}


	public interface ISealedClassWrapperFactory
	{
		ISealedClassWrapper Create(params object[] args);
		ISealedClassWrapper Create();
	}


	public class SealedClassWrapperFactory : ISealedClassWrapperFactory
	{
		public virtual ISealedClassWrapper Create(params object[] args)
		{
			return (ISealedClassWrapper)System.Activator.CreateInstance(typeof(SealedClassWrapper), args);
		}

		public virtual ISealedClassWrapper Create()
		{
			return new SealedClassWrapper(); 
		}
	}

}
// TestLibrary.Class+NestetClass
/* ---------------------------------------------------------------------------- *
 *		The code is generated by 'T4Wrap' C# proxy generator T4 template		*
 * ---------------------------------------------------------------------------- */

namespace TestLibrary.Proxies
{
	public interface INestetClassWrapper
	{


		#region Methods
	 	void Method1();
	 	void Method2(string str);
		#endregion
	}

	public class NestetClassWrapper : System.Object, INestetClassWrapper
	{
		//private TestLibrary.Class.NestetClass Inner;

		internal TestLibrary.Class.NestetClass Inner { get; }

		#region Constructors
		public NestetClassWrapper()
		{
			this.Inner = new TestLibrary.Class.NestetClass();
		}
		#endregion




		#region Methods
		public virtual void Method1()
		{
			Inner.Method1();
		}
		public virtual void Method2(string str)
		{
			Inner.Method2(str);
		}
		#endregion

	}


	public interface INestetClassWrapperFactory
	{
		INestetClassWrapper Create(params object[] args);
		INestetClassWrapper Create();
	}


	public class NestetClassWrapperFactory : INestetClassWrapperFactory
	{
		public virtual INestetClassWrapper Create(params object[] args)
		{
			return (INestetClassWrapper)System.Activator.CreateInstance(typeof(NestetClassWrapper), args);
		}

		public virtual INestetClassWrapper Create()
		{
			return new NestetClassWrapper(); 
		}
	}

}
// TestLibrary.Class+publicDelegate1
/* ---------------------------------------------------------------------------- *
 *		The code is generated by 'T4Wrap' C# proxy generator T4 template		*
 * ---------------------------------------------------------------------------- */

namespace TestLibrary.Proxies
{
	public delegate void publicDelegate1Wrapper (); 

}


// TestLibrary.Class+publicDelegate2
/* ---------------------------------------------------------------------------- *
 *		The code is generated by 'T4Wrap' C# proxy generator T4 template		*
 * ---------------------------------------------------------------------------- */

namespace TestLibrary.Proxies
{
	public delegate void publicDelegate2Wrapper (string s); 

}


// TestLibrary.Class+publicDelegate3
/* ---------------------------------------------------------------------------- *
 *		The code is generated by 'T4Wrap' C# proxy generator T4 template		*
 * ---------------------------------------------------------------------------- */

namespace TestLibrary.Proxies
{
	public delegate string publicDelegate3Wrapper (string s); 

}


		
